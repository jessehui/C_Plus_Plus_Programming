# C++ 程序设计语言 Notes

###1 Hello World
Example:
```C++
#include <iostream>

int main()
{
	std::cout << "Hellow World.\n"

}
```

###2 异常捕捉
使异常所造成的奇怪现象最小化的第一种方式用一个try块作为体

```C++
try{
	//code
}

catch (out_of_range){
	cerr << "Range Error\n";
}

catch (...){
	cerr << "Unknown exception thrown\n";
}
```

###3 迭代器 iterator
迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。迭代器修改了常规指针的接口，所谓迭代器是一种概念上的抽象：那些行为上像迭代器的东西都可以叫做迭代器。然而迭代器有很多不同的能力，它可以把抽象容器和通用算法有机的统一起来。

迭代器提供一些基本操作符：*、++、==、!=、=。这些操作和C/C++“操作array元素”时的指针接口一致。不同之处在于，迭代器是个所谓的复杂的指针，具有遍历复杂数据结构的能力。其下层运行机制取决于其所遍历的数据结构。因此，每一种容器型都必须提供自己的迭代器。事实上每一种容器都将其迭代器以嵌套的方式定义于内部。因此各种迭代器的接口相同，型号却不同。这直接导出了泛型程序设计的概念：所有操作行为都使用相同接口，虽然它们的型别不同。

###4 类型
布尔类型（bool）,字符类型（char），整数类型(int), 放到一起称为整型（integral type）。
整型和浮点类型一起称为算术类型。
枚举和类称为用户定义类型，因为他们必须由用户定义出来，不能事先未声明而直接使用。
`int（c）`将给出字符c的整数值
整数类型（int）后缀U可以用于显示地写出unsigned文字量。后缀L可以用于明显的写出long文字量。例如 `int a = 3U`.
浮点类型： float单精度， double双精度， long double扩展精度

###5 枚举类型
enum是计算机编程语言中的一种数据类型。枚举类型：在实际问题中，有些变量的取值被限定在一个有限的范围内。例如，一个星期内只有七天，一年只有十二个月，一个班每周有六门课程等等。
在“枚举”类型的定义中列举出所有可能的取值，被说明为该“枚举”类型的变量取值不能超过定义的范围。应该说明的是，枚举类型是一种基本数据类型，而不是一种构造类型，因为它不能再分解为任何基本类型。
枚举符可以被赋值。按默认方式，枚举符所赋的值从0开始递增。
如果某个枚举中所有枚举值均非负，该枚举的表示范围就是0-(2^k-1),其中的2^k就是能使所有枚举符位于此范围内的最小的2次幂。如果存在负的枚举值，该枚举的取值范围就是[-2^k:2^k-1]。
一个整型值可以显式地转换到一个枚举值，除非这种转换的结果位于该枚举的范围之内，否则就是无定义的。
一个枚举的`sizeof()`就是能够容纳其范围的整型的sizeof。
一个枚举是一个用户定义的类型，所以用户可以为枚举定义它自身的操作.


###6 命名规则
用于较大的作用域的名族应该是相对比较长的更加明确的名字.然而如果在很小的作用域里只使用那些短小而熟悉的名字,如x,i,p等,代码会显得更清晰些.(类和名字空间可用来保持较小的作用域).
让那些频繁使用的名字相对比较短,将较长的名字保留给不常用的实体,这种做法也很有价值. 


###7 作用域解析运算符
`::`作用域解析运算符,就是当局部变量和全局变量名字重叠的时候，指定某变量一定是来自全局变量。


###8 typedef
为类型声明了一个新的名字,而不是声明一个指定类型的对象
```C++
typedef char* Pchar;
typedef unsigned char uchar;//原本较笨拙的类型名的缩写

typedef int int32;
typedef short int16;
//将对某个类型的直接引用限制到一个地方. 如果我们在所有可能需要较大的整数的地方都用int32, 那么就很容易将我们的程序移植到另一个sizeof(int)是2的机器上,因为只要在代码中重新定义
typedef long int32;

```

###9 指针
```C++
char** ppc;//到字符的指针的指针

int (*fp) (char*);//到函数的指针,以char*为参数
int* f(char*);//以char*为参数, 返回一个int类型的指针(int*)
```

没有任何对象被分配到地址0,因此0也被当做一个指针文字量, 表明一个指针当时并没有指向任何对象. C中流行的是用一个宏NULL表示0指针. C++取消了这一定义. 如果感到必须使用,可以重新定义:
`const int NULL = 0; `

###10 数组
数组元素的个数, 即数组的界,必须是一个常量表达式. 如果是需要变化的界,那么要用vector
Example:
```C++
void f(int i)
{
	int v1[i];//错误
	vector<int> v2(i);//可以使用
}
```

###11 字符串文字量
如果我们希望一个字符串保证能够被修改,那么就必须将有关的字符复制到数组里
```C++
void f()
{
 char p[] = "Zeno";
 p[0] = "R";//合法
}



void g()
{
	char* p = "Plato";
	p[4] = "e";//不合法
}
```
字符串文字量是静态分配的, 所以让函数返回他们是安全的.
```C++
const char* error_message(int i)
{
	//...
	//...
	return "Range Error";
}
```
在应用于指针时,==比较的是地址(指针的值),而不是被指的东西.
编译器将拼接器连续的字符串. 将空字符放到字符串里也是可能的, 但是大部分程序将不会去考虑在这个字符的后边还有其他字符. 举例来说,字符串"Jers\000Munk"将被各种标准库函数,例如strcpy()和strlen(),当做"Jers"看待.
带有前缀L的字符串,例如L"angst",是宽字符的字符串


###12 到数组的指针
```C++
int v[] = {1,2,3,4};
int* p1 = v;
int* p2 = &v[0]; 等价于上一句
int* p3 = &v[4];//合法
```
取得超出一个数组结束之后一个元素位置的指针是可以做到的. 但指针并不指向数组里的一个元素, 因此不能通过它去读或者写. 取得数组开始元素之前的元素地址是无定义的, 应该避免.
++对指针做增量操作,使其索引这个数组中的下一个字符.
将算术运算符+,-,++,--应用于指针的结果依赖于被指对象的类型.
复杂的指针算术通常并不必要,最好避免使用.

###13 指针和常量
讲一个指针的声明用const预先固定将使那个`对象`而不是使这个`指针`成为常量. 
要将`指针`本身而不是被指`对象`声明为常量,必须使用声明运算符*const, 而不能只用简单的const
```C++
char s[] = "Gorm";
char p[] = "whatever";

const char* pc = s;//指向常量(指向的东西是一个不能更改的常量)
pc[3] = 'g'; 	//错误, pc指向常量
pc = p; 		//可以,当p也为const常量

char *const cp = s;//常量指针(指向的东西不能变化,东西本身可以变)
cp[3] = 'a';		//可以
cp = p; 		//不可以, cp一定指向s

const char *const cpc = s;
cpc[3] = 'a';		//不可以
cpc = p;			//不可以

```
并没有`const*`声明符, 所以出现在*之前的const是作为基础类型的一部分.



















